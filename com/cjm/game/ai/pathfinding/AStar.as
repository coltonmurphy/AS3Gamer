package cjm.game.ai.pathfinding{	import cjm.game.ai.pathfinding.IGraph;	import cjm.game.ai.pathfinding.INode;	import cjm.game.ai.pathfinding.IHeuristic;		public class AStar	{				public var heuristic:IHeuristic;		public var endNode:INode;		public var startNode:INode;		private var _open:Array;		private var _closed:Array;		private var _graph:IGraph;		private var _path:Array;				public function AStar()		{			trace("new AStar()");		}				public function findPath(graph:IGraph, sn:INode, en:INode):Boolean		{			trace("AStar.findPath()");			trace("-- graph: " + graph);			trace("-- sn: " + sn);			trace("-- en: " + en);						_graph = graph;			_open = new Array();			_closed = new Array();						startNode = sn;			endNode = en;						startNode.g = 0;			startNode.h = heuristic.estimateCost(startNode, endNode);			startNode.f = startNode.g + startNode.h;			trace("-- startNode.h: " + startNode.h + " .f: " + startNode.f);						return search();		}						public function search():Boolean		{			var node:INode = startNode;			var test:INode;			var neighbours:Array;			var cost:Number;			var g:Number;			var h:Number;			var f:Number;						while(node != endNode)			{				neighbours = _graph.getNeighbours(node);				while(neighbours.length)				{					test = neighbours.pop() as INode;					if(test == node || test.walkable == false)					{						continue;					}					cost = _graph.getCost(node, test);										g = node.g + cost;					// * test.costMultiplier;					h = heuristic.estimateCost(test, endNode);					f = g + h;										if(isOpen(test) || isClosed(test))					{						if(test.f > f)						{							test.f = f;							test.g = g;							test.h = h;							test.parentNode = node;						}					}					else					{						test.f = f;						test.g = g;						test.h = h;						test.parentNode = node;						_open.push(test);					}				}							_closed.push(node);				if(_open.length == 0)				{					trace("no path found");					return false				}				_open.sortOn("f", Array.NUMERIC);				node = _open.shift() as INode;			}			buildPath();			return true;					}						private function buildPath():void		{			_path = new Array();			var node:INode = endNode;			_path.push(node);			while(node != startNode)			{				node = node.parentNode;				_path.unshift(node);			}		}				public function get path():Array		{			return _path;		}				private function isOpen(node:INode):Boolean		{			for(var i:int = 0; i < _open.length; i++)			{				if(_open[i] == node)				{					return true;				}			}			return false;		}				private function isClosed(node:INode):Boolean		{			for(var i:int = 0; i < _closed.length; i++)			{				if(_closed[i] == node)				{					return true;				}			}			return false;		}						public function get visited():Array		{			return _closed.concat(_open);		}	}}