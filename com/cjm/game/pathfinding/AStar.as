spackage com.cjm.game.ai.pathfinding{	import com.cjm.game.pathfinding.IGraph;	import com.cjm.game.pathfinding.IGraph;	import com.cjm.game.pathfinding.INode;	import com.cjm.game.pathfinding.IHeuristic;	import com.cjm.game.pathfinding.INode;	import com.cjm.game.pathfinding.INode;	import com.cjm.game.pathfinding.IPath;	import com.cjm.game.pathfinding.Path;		public class AStar extends SearchAlgorithm	{		private var _currentNode:INode;		private var _currentNeighbor:INode;		private var _currentNeighbors:Vector.<INode>;		private var _currentCost:Number;		private var _g:Number;		private var _h:Number;		private var _f:Number;				override public function preProcess():IPath		{			_open = new Vector.<INode>;			_closed = new Vector.<INode>;			_currentNode = _startNode;			_currentNeighbor = _graph.getNeighbours( _currentNode );			_currentNeighbors = new Vector.<INode>;			_currentCost = 0;			_g = 0;			_h = 0;			_f = 0;		}			//For creating the result		public function postProcess():void		{			var path = new Path();			path.addNode( _endNode );						var node:INode = _endNode;						while(node != _startNode)			{				node = node.parent;				path.addNode(node);			}						_result = path;		}				/*This is called within a while loop for full processing via super.process()*/		override public function processOnce():void		{			_currentNeighbors = _graph.getNeighbours( _currentNode );							while( _currentNeighbors.length )			{				_currentNeighbor = _currentNeighbors.pop() as INode;								//Do not check yourself				if ( _currentNeighbor == _currentNode )continue;								_currentCost = _graph.getCost( _currentNode, _currentNeighbor );				_g = _currentNode.g + _currentCost;				_h = _heuristic.estimateCost( _currentNeighbor, _endNode );				_f = _g + _h;								//If already evaluated by different neighbor reassess new cost with this neighbor				if ( _open.indexOf  ( _currentNeighbor ) > -1 || 					 _closed.indexOf( _currentNeighbor ) > -1)				{					if( _currentNeighbor.f > _f )					{						_currentNeighbor.f = _f;						_currentNeighbor.g = _g;						_currentNeighbor.h = _h;						_currentNeighbor.parent = _currentNode;					}				}				else				{					_currentNeighbor.f = _f;					_currentNeighbor.g = _g;					_currentNeighbor.h = _h;					_currentNeighbor.parent = _currentNode;										_open.push( _currentNeighbor );				}			}					_closed.push( _currentNode );						if( _open.length == 0 )				return false;						_open.sortOn( "f", Array.NUMERIC );//PriorityList						_currentNode = _open.shift() as INode;		}	}}