spackage com.cjm.game.ai.pathfinding{	import com.cjm.game.pathfinding.IGraph;	import com.cjm.game.pathfinding.IGraph;	import com.cjm.game.pathfinding.IGraph;	import com.cjm.game.pathfinding.INode;	import com.cjm.game.pathfinding.IHeuristic;	import com.cjm.game.pathfinding.INode;	import com.cjm.game.pathfinding.INode;	import com.cjm.game.pathfinding.INode;	import com.cjm.game.pathfinding.IPath;	import com.cjm.game.pathfinding.Path;		public class AStar extends SearchAlgorithm	{		private var _graph:IGraph;		private var _currentNode:INode;		private var _currentNeighbor:INode;		private var _currentNeighbors:Vector.<INode>;		private var _g:Number;		private var _h:Number;		private var _f:Number;				public function AStar ( g:IGraph, a:INode, b:INode, h:IHeuristic, useTicks:Boolean = false, tickLimit:Number = -1 )		{			super( g, a, b, h, useTicks, tickLimit );						_open = new Vector.<INode>;			_closed = new Vector.<INode>;			_currentNode = _startNode;			_g = 0;			_h = 0;			_f = 0;		}		override public function getResult():*		{			if ( null == _result )			{				if ( isComplete() )				{					var path = new Path();					path.addNode( _endNode );									var node:INode = _endNode;										while(node != _startNode)					{						node = node.parent;						path.addNode(node);					}										_result = path;				}			}						return _result;		}		/*This is called within a while loop for full processing via super.process()*/		override public function cycleOnce():Boolean		{			_currentNeighbors = _graph.getNeighbours( _currentNode );							while( _currentNeighbors.length )			{				_currentNeighbor = _currentNeighbors.pop() as INode;								//Do not check yourself				if ( _currentNeighbor == _currentNode )continue;								//Get cost of heuristic				_h = _heuristic.estimateCost( _currentNeighbor, _endNode );								//Calculate the real/total cost to this node from the source				_g = _currentNode.g + _graph.getCost( _currentNode, _currentNeighbor );								_f = _g + _h;								//If already evaluated by different neighbor reassess new cost with this neighbor				if ( _open.indexOf  ( _currentNeighbor ) > -1 || 					 _closed.indexOf( _currentNeighbor ) > -1)				{					if( _currentNeighbor.f > _f )					{						_currentNeighbor.f = _f;						_currentNeighbor.g = _g;						_currentNeighbor.h = _h;						_currentNeighbor.parent = _currentNode;					}				}				//If the node has not been added to the frontier then assign costs and add it				else				{					_currentNeighbor.f = _f;					_currentNeighbor.g = _g;					_currentNeighbor.h = _h;					_currentNeighbor.parent = _currentNode;										_open.push( _currentNeighbor );				}			}					_closed.push( _currentNode );						if( _open.length == 0 )				return false;						_open.sortOn( "f", Array.NUMERIC );//PriorityList						_currentNode = _open.shift() as INode;		}				return _complete = (_currentNode == _endNode);	}}