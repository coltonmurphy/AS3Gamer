package formosus.tasks.threading{	import formosus.collections.ICollection;	import formosus.collections.iterators.IIterator;	import formosus.collections.List;	import formosus.collections.PriorityQueue;	import flash.events.TimerEvent;	import flash.utils.Timer;	/**	 * 	 * @author Mark	 */	public final class ThreadPool	{		/**		 * Variable which indicates how many iterations per tick should be executed		 * 		 * @default 6000		 */		static public  var ITERATIONS_PER_TICK:int = 1000;		/**		 * Variable which indicates how many milliseconds interval there should be on each tick		 *  		 * @default 100 		 */		static public  var ITERATION_INTERVAL:int = 100;				static private  var _instance:ThreadPool;		static private  var _jobs:PriorityQueue;		//--------------------------------------		//   Static Function 		//--------------------------------------		/**		 * 		 * @param thread Add a new thread to threadpool		 */		static public function add(thread:IThread):void		{			if(_instance == null)			{				_instance = new ThreadPool(new Private());			}						_jobs.enqueue(thread);						if(!_instance._jobTicker.running)			{				_instance._jobTicker.start();				}		}		//--------------------------------------		//   Properties 		//--------------------------------------		private var _jobTicker:Timer;		//--------------------------------------		//   Constructor 		//--------------------------------------		/**		 * Private constructor		 * 		 * @param access Private constructor		 */		public function ThreadPool(access:Private)		{			if (access == null)			{				throw new Error("SingletonException");			}						_jobs = new PriorityQueue();						this._jobTicker = new Timer(ITERATION_INTERVAL);			this._jobTicker.addEventListener(TimerEvent.TIMER, this.handleTick);		}		//--------------------------------------		//   Private functions 		//--------------------------------------		/**		 * Handles the timer tick		 * 		 * @param event Timer event		 */		private function handleTick(event:TimerEvent):void 		{			//reverse it//			_jobs = _jobs.reverse() as PriorityQueue;									var thread:IThread;			var newJobs:ICollection = new List();			var iterationsPerThread:int = ITERATIONS_PER_TICK / _jobs.length;			var iterationsOverhead:int;			var iterationsAllocated:int;			var iterationsPerTick:int = ITERATIONS_PER_TICK;			 			//iterate of the thread queue, priotized!			while(iterationsPerTick > 0 && (thread = _jobs.dequeue() as IThread))			{				//check if we have IProgressiveThread so we can cut down on thread cost :)				if(thread is IProgressiveThread)				{					//calculcate the overhead					iterationsOverhead = Math.abs(						Math.min(							0,							IProgressiveThread(thread).iterationsTotal - ( IProgressiveThread(thread).iterationsDone - iterationsPerThread )						)					);										//calculate how many iterations we should allocate					iterationsAllocated = iterationsPerTick + iterationsOverhead;				}				else				{					//set the iterations allocated					iterationsAllocated = iterationsPerTick;				}				//make the iterations				while(iterationsAllocated--)				{					//execute the function					thread.tick();										//decrease iterations per tick					iterationsPerTick--;										//check if this thread is an progressive thread					if(thread is IProgressiveThread)					{						//update the progress						thread.onProgress.dispatch(thread, ++IProgressiveThread(thread).iterationsDone / IProgressiveThread(thread).iterationsTotal);					}										//check if we are done					if(thread.isDone)					{						//if we are done dispatch an event						thread.onComplete.dispatch(thread);												//dispose the thread						thread.dispose();												//break away from the while						break;					}									}								//check if we are done				if(!thread.isDone)				{					//if we are not done, restack the thread again					newJobs.add(thread);				}								//recalculate the iterations per thread				iterationsPerThread = iterationsPerTick / _jobs.length;			}									//stack them to the current job stack			var jobIterator:IIterator = newJobs.getIterator();						while(jobIterator.next())			{				_jobs.enqueue( jobIterator.current() );			}					//check if there are any new jobs			if(newJobs.length == 0)			{				//else pause the ticker/timer				this._jobTicker.stop();			}		}	}}class Private{}